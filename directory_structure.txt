Directory Structure:

├── posts
│   ├── about.md
│   └── post1.md
├── requirements.txt
├── server.c
├── src
│   ├── script.js
│   └── styles.css
└── templates
    └── index.html

File Contents:
-------------------------
.\requirements.txt
-------------------------
  1 | flask
  2 | waitress

-------------------------

-------------------------
.\server.c
-------------------------
  1 | /////////////////////////////////////////////////////
  2 | // Made by Mikus (Cappuch) - 2024 December 17th    //
  3 | //                                                 //
  4 | // Simple Web Server (HTTP)                        //
  5 | // 200 lines worth of wasted storage and time      //
  6 | //                                                 //
  7 | //                                                 //
  8 | // Compile with: gcc server.c -o server            //
  9 | // Run with: ./server (if on linux/unix)           //
 10 | //                                                 //
 11 | // MIT License                                     //
 12 | /////////////////////////////////////////////////////
 13 | 
 14 | #ifdef _WIN32
 15 |     #include <winsock2.h>
 16 |     #include <ws2tcpip.h>
 17 |     #pragma comment(lib, "ws2_32.lib")
 18 |     #include <direct.h>
 19 |     #define mkdir(dir, mode) _mkdir(dir)
 20 | #else
 21 |     #include <sys/socket.h>
 22 |     #include <netinet/in.h>
 23 |     #include <unistd.h>
 24 |     #include <sys/stat.h>
 25 | #endif
 26 | 
 27 | #include <stdio.h>
 28 | #include <stdlib.h>
 29 | #include <string.h>
 30 | #include <sys/types.h>
 31 | #include <sys/stat.h>
 32 | #include <errno.h>
 33 | 
 34 | #define PORT 8080
 35 | #define BUFFER_SIZE 4096
 36 | #define MAX_PATH_LENGTH 256
 37 | 
 38 | void handle_client(int client_socket);
 39 | char* serve_file(const char* filepath, const char* content_type, size_t* content_length);
 40 | char* create_response(const char* status, const char* content_type, const char* content, size_t content_length);
 41 | void route_request(int client_socket, const char* path);
 42 | 
 43 | int main() {
 44 |     #ifdef _WIN32
 45 |         WSADATA wsaData;
 46 |         if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
 47 |             printf("WSAStartup failed\n"); // Hey..... Ur stuff is not working... Works on my machine11!
 48 |             return 1;
 49 |         }
 50 |     #endif
 51 | 
 52 |     struct stat st;
 53 |     if (stat("posts", &st) == -1) {
 54 |         printf("Creating posts directory\n");
 55 |         #ifdef _WIN32
 56 |             if (_mkdir("posts") != 0) {
 57 |                 printf("Error creating directory: %s\n", strerror(errno));
 58 |                 return 1;
 59 |             }
 60 |         #else
 61 |             if (mkdir("posts", 0700) != 0) { // 0700 = rwx------
 62 |                 printf("Error creating directory: %s\n", strerror(errno));
 63 |                 return 1;
 64 |             }
 65 |         #endif
 66 |     }
 67 | 
 68 |     int server_socket;
 69 |     struct sockaddr_in server_addr, client_addr;
 70 |     socklen_t client_len = sizeof(client_addr);
 71 | 
 72 |     server_socket = socket(AF_INET, SOCK_STREAM, 0);
 73 |     if (server_socket < 0) {
 74 |         printf("Error creating socket\n");
 75 |         return 1;
 76 |     }
 77 | 
 78 |     int opt = 1;
 79 |     setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));
 80 | 
 81 |     memset(&server_addr, 0, sizeof(server_addr));
 82 |     server_addr.sin_family = AF_INET;
 83 |     server_addr.sin_addr.s_addr = INADDR_ANY;
 84 |     server_addr.sin_port = htons(PORT);
 85 | 
 86 |     if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
 87 |         printf("Error binding socket\n");
 88 |         return 1;
 89 |     }
 90 | 
 91 |     if (listen(server_socket, 1) < 0) {
 92 |         printf("Error listening\n");
 93 |         return 1;
 94 |     }
 95 | 
 96 |     printf("Server listening on 0.0.0.0:%d\n", PORT);
 97 |     printf("http://localhost:%d\n", PORT);
 98 | 
 99 |     while (1) {
100 |         int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);
101 |         if (client_socket < 0) {
102 |             printf("Error accepting connection\n");
103 |             continue;
104 |         }
105 |         handle_client(client_socket);
106 |     }
107 | 
108 |     return 0;
109 | }
110 | 
111 | void handle_client(int client_socket) {
112 |     char buffer[BUFFER_SIZE];
113 |     memset(buffer, 0, BUFFER_SIZE);
114 | 
115 |     ssize_t bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
116 |     if (bytes_received > 0) {
117 |         char method[16], path[MAX_PATH_LENGTH], protocol[16];
118 |         sscanf(buffer, "%s %s %s", method, path, protocol);
119 |         
120 |         route_request(client_socket, path);
121 |         
122 |         printf("Request: %s %s from client\n", method, path);
123 |     }
124 | 
125 |     #ifdef _WIN32
126 |         closesocket(client_socket);
127 |     #else
128 |         close(client_socket);
129 |     #endif
130 | }
131 | 
132 | char* serve_file(const char* filepath, const char* content_type, size_t* content_length) {
133 |     FILE* file = fopen(filepath, "rb");
134 |     if (!file) {
135 |         *content_length = 13;
136 |         return strdup("404 Not Found");
137 |     }
138 | 
139 |     fseek(file, 0, SEEK_END);
140 |     *content_length = ftell(file);
141 |     fseek(file, 0, SEEK_SET);
142 | 
143 |     char* content = malloc(*content_length + 1);
144 |     if (!content) {
145 |         fclose(file);
146 |         return NULL;
147 |     }
148 | 
149 |     fread(content, 1, *content_length, file);
150 |     content[*content_length] = '\0';
151 |     fclose(file);
152 | 
153 |     return content;
154 | }
155 | 
156 | char* create_response(const char* status, const char* content_type, const char* content, size_t content_length) {
157 |     char* response = malloc(BUFFER_SIZE);
158 |     if (!response) return NULL;
159 | 
160 |     snprintf(response, BUFFER_SIZE,
161 |         "HTTP/1.1 %s\r\n"
162 |         "Content-Type: %s\r\n"
163 |         "Content-Length: %zu\r\n"
164 |         "\r\n"
165 |         "%s",
166 |         status, content_type, content_length, content);
167 | 
168 |     return response;
169 | }
170 | 
171 | void route_request(int client_socket, const char* path) {
172 |     size_t content_length;
173 |     char* content;
174 |     char* response;
175 | 
176 |     if (strcmp(path, "/") == 0 || strcmp(path, "/index.html") == 0) {
177 |         content = serve_file("templates/index.html", "text/html", &content_length);
178 |         response = create_response("200 OK", "text/html", content, content_length);
179 |     }
180 |     else if (strncmp(path, "/posts/", 7) == 0) {
181 |         char filepath[MAX_PATH_LENGTH];
182 |         snprintf(filepath, MAX_PATH_LENGTH, "posts/%s", path + 7);
183 |         content = serve_file(filepath, "text/plain", &content_length);
184 |         response = create_response("200 OK", "text/plain", content, content_length);
185 |     }
186 |     else if (strcmp(path, "/styles.css") == 0) {
187 |         content = serve_file("src/styles.css", "text/css", &content_length);
188 |         response = create_response("200 OK", "text/css", content, content_length);
189 |     }
190 |     else if (strcmp(path, "/script.js") == 0) {
191 |         content = serve_file("src/script.js", "application/javascript", &content_length);
192 |         response = create_response("200 OK", "application/javascript", content, content_length);
193 |     }
194 |     else {
195 |         content = "404 Not Found";
196 |         content_length = strlen(content);
197 |         response = create_response("404 Not Found", "text/plain", content, content_length);
198 |     }
199 | 
200 |     if (response) {
201 |         send(client_socket, response, strlen(response), 0);
202 |         free(response);
203 |     }
204 | 
205 |     if (content && content != "404 Not Found") {
206 |         free(content);
207 |     }
208 | }
-------------------------

-------------------------
.\posts\about.md
-------------------------
  1 | # About Me
  2 | My name is Mikus! I'm 16 years old. I'm a student, and a 'developer' if you could call me one. I like to do miscellaneous machine learning research, mostly tailoring towards audio and vision.
  3 | 
  4 | ## Highlights
  5 | - I'm 16 years old
  6 | - I'm a student (4th year in Ireland, 10th grade in the US)
  7 | - Somehow wound up at Microsoft Irish HQ for a day presenting a self-driving car project (I'm not sure how that happened either)
  8 | - Also wound up at BD (Becton Dickinson), presenting an OCR project
  9 | - I like to do machine learning research
 10 | - I'm a developer
 11 | 
 12 | ## Projects
 13 | - [**Mikus's WebUI**](https://github.com/cappuch/MikusWebUI) - Interface for language models written in Python, HTML, CSS and JS.
 14 | - [**MLKernel**](https://github.com/cappuch/mlkernel) - A machine learning-focused kernel for 32 bit systems.
 15 | - [**AppInstaller**](https://github.com/cappuch/appinstaller) - A simple package manager for Windows.
 16 | - [**Audio SuperRes**](https://github.com/cappuch/Audio-SuperRes) - A machine learning model for audio super-resolution. (unmaintained)
 17 | - [**Tool Markup Language**](https://github.com/cappuch/Tool-Markup-Language) - A simple markup language for providing tools to LLMS.
 18 | - [**W5XDE**](https://github.com/rndmcoolawsmgrbg/WIIIIIDE) - Distributed training for home users.
 19 | - [**Enhanced Inverse Dynamics Prediction**](https://github.com/open-sdetenn/EIDP) - A machine learning model for predicting inverse dynamics in robotics. (in this case, a car.)
 20 | 
 21 | ## Contact
 22 | - [**Email**](mailto:ilovevisualstudiocode@gmail.com)
 23 | - [**GitHub**](https://github.com/cappuch)
 24 | - **Discord** - `mikus____`
 25 | - [**Hugging Face**](https://huggingface.co/cappuch)
-------------------------

-------------------------
.\posts\post1.md
-------------------------
  1 | # Transformer TTS Experiments  
  2 | **Date**: 16th December 2024
  3 | 
  4 | Ah, the transformer. It's a model we all know and love for its versatility. Whether it's text (BERT), images (ViT), or even audio (SpeechT5), transformers have proven themselves across the board. But here's the thing—most of these models are a few years old now (2018, 2020, 2020, respectively).
  5 | 
  6 | I wanted to explore how transformers would perform in the audio domain. The challenge? While transformers excel at processing text, audio is a whole different ball game. Audio is sampled at thousands of points per second, whereas text is just a sequence of tokens.
  7 | 
  8 | So, what's the first step? How do we "tokenize" or "squash" audio? One obvious approach is using a spectrogram. A spectrogram visualizes the frequency spectrum of a signal over time, turning audio into a 2D image that a transformer model can process. However, there's an issue with spectrograms, which is that converting the result to a sequence of tokens can be quite lossy.
  9 | Back to the drawing board.
 10 | 
 11 | Another idea is to use an "autoencoder." This type of neural network learns efficient data codings in an unsupervised way. The goal is to create a compact representation of the data, which is perfect for reducing audio to a smaller form that can be fed into the transformer model.
 12 | 
 13 | Now, how do we implement the autoencoder? One option is to use convolutional neural networks (CNNs) or recurrent neural networks (RNNs), which seem like a good fit for the task.
 14 | 
 15 | ## Autoencoding?
 16 | 
 17 | Autoencoders are a type of neural network that learns to compress data. They consist of two parts: an encoder that compresses the data into a latent space representation and a decoder that reconstructs the original data from the latent space.
 18 | 
 19 | It's literally like magic. You feed in a bunch of data, and the autoencoder learns to compress it into a smaller form. Then, you can feed this compressed data into a transformer model, which can process it more efficiently.
 20 | 
 21 | ### Model Architecture
 22 | 
 23 | For the autoencoder, I decided to go with a simple CNN-based architecture. 
 24 | ```python
 25 | import torch
 26 | import torch.nn as nn
 27 | import torchaudio
 28 | import torchaudio.transforms as T
 29 | 
 30 | class Autoencoder(nn.Module):
 31 |     def __init__(self):
 32 |         super(Autoencoder, self).__init__()
 33 | 
 34 |         self.encoder = nn.Sequential(
 35 |             nn.Conv1d(1, 32, kernel_size=3, stride=2, padding=1),
 36 |             nn.ReLU(),
 37 |             nn.Conv1d(32, 64, kernel_size=3, stride=2, padding=1),
 38 |             nn.ReLU(),
 39 |             nn.Conv1d(64, 128, kernel_size=3, stride=2, padding=1),
 40 |             nn.ReLU(),
 41 |             nn.Conv1d(128, 256, kernel_size=3, stride=2, padding=1),
 42 |             nn.ReLU(),
 43 |         )
 44 | 
 45 |         self.decoder = nn.Sequential(
 46 |             nn.ConvTranspose1d(256, 128, kernel_size=3, stride=2, padding=1, output_padding=1),
 47 |             nn.ReLU(),
 48 |             nn.ConvTranspose1d(128, 64, kernel_size=3, stride=2, padding=1, output_padding=1),
 49 |             nn.ReLU(),
 50 |             nn.ConvTranspose1d(64, 32, kernel_size=3, stride=2, padding=1, output_padding=1),
 51 |             nn.ReLU(),
 52 |             nn.ConvTranspose1d(32, 1, kernel_size=3, stride=2, padding=1, output_padding=1),
 53 |             nn.Sigmoid()
 54 |         )
 55 | 
 56 |     def forward(self, x):
 57 |         x = self.encoder(x)
 58 |         x = self.decoder(x)
 59 |         return x
 60 | ```

-------------------------

-------------------------
.\src\script.js
-------------------------
  1 | function loadPost(filePath) {
  2 |     const contentContainer = document.getElementById('post-content');
  3 |     if (filePath === 'about') {
  4 |       filePath = 'posts/about.md';
  5 |     }
  6 | 
  7 |     fetch(filePath)
  8 |       .then(response => {
  9 |         if (!response.ok) {
 10 |           throw new Error('Failed to load post');
 11 |         }
 12 |         return response.text();
 13 |       })
 14 |       .then(markdown => {
 15 |         contentContainer.innerHTML = marked.parse(markdown);
 16 |       })
 17 |       .catch(error => {
 18 |         contentContainer.innerHTML = `<p>Error loading post: ${error.message}</p>`;
 19 |       });
 20 |   }
 21 | 
 22 |   document.addEventListener('DOMContentLoaded', () => {
 23 |     loadPost('about');
 24 |   });

-------------------------

-------------------------
.\src\styles.css
-------------------------
  1 | /* General Reset */
  2 | * {
  3 |   margin: 0;
  4 |   padding: 0;
  5 |   box-sizing: border-box;
  6 |   font-family: Arial, sans-serif;
  7 | }
  8 | 
  9 | body {
 10 |   display: flex;
 11 |   height: 100vh;
 12 |   background-color: #121212;
 13 |   color: #fff;
 14 | }
 15 | 
 16 | .sidebar {
 17 |   width: 250px;
 18 |   background-color: #1e1e1e;
 19 |   padding: 20px;
 20 |   overflow-y: auto;
 21 | }
 22 | 
 23 | .sidebar h2 {
 24 |   margin-bottom: 20px;
 25 |   font-size: 1.5em;
 26 |   color: #f0f0f0;
 27 | }
 28 | 
 29 | .sidebar ul {
 30 |   list-style: none;
 31 | }
 32 | 
 33 | .sidebar li {
 34 |   padding: 10px;
 35 |   cursor: pointer;
 36 |   border-radius: 5px;
 37 |   transition: background 0.3s;
 38 | }
 39 | 
 40 | .sidebar li:hover {
 41 |   background-color: #333;
 42 | }
 43 | 
 44 | .content {
 45 |   flex-grow: 1;
 46 |   padding: 50px;
 47 |   overflow-y: auto;
 48 | }
 49 | 
 50 | #post-content h1, #post-content h2, #post-content h3,
 51 | #post-content h4, #post-content h5, #post-content h6 {
 52 |   margin-top: 20px;
 53 |   margin-bottom: 10px;
 54 |   line-height: 1.3;
 55 | }
 56 | 
 57 | #post-content p {
 58 |   margin-bottom: 15px;
 59 |   line-height: 1.6;
 60 | }
 61 | 
 62 | #post-content ul, #post-content ol {
 63 |   margin: 15px 0;
 64 |   padding-left: 25px;
 65 | }
 66 | 
 67 | #post-content li {
 68 |   margin-bottom: 5px;
 69 | }
 70 | 
 71 | #post-content blockquote {
 72 |   margin: 20px 0;
 73 |   padding: 10px 20px;
 74 |   border-left: 4px solid #555;
 75 |   background-color: #1e1e1e;
 76 | }
 77 | 
 78 | #post-content pre {
 79 |   background-color: #2e2e2e;
 80 |   padding: 15px;
 81 |   overflow-x: auto;
 82 |   border-radius: 5px;
 83 |   margin: 15px 0;
 84 | }
 85 | 
 86 | #post-content code {
 87 |   font-family: monospace;
 88 |   background-color: #2e2e2e;
 89 |   padding: 2px 5px;
 90 |   border-radius: 3px;
 91 | }
 92 | 
 93 | #post-content img {
 94 |   max-width: 100%;
 95 |   height: auto;
 96 |   margin: 15px 0;
 97 |   border-radius: 5px;
 98 | }
 99 | 
100 | #post-content a {
101 |   color: #00bcd4;
102 |   text-decoration: none;
103 | }
104 | 
105 | #post-content a:hover {
106 |   text-decoration: underline;
107 | }
-------------------------

-------------------------
.\templates\index.html
-------------------------
  1 | <!DOCTYPE html>
  2 | <html lang="en">
  3 | <head>
  4 |   <meta charset="UTF-8">
  5 |   <meta name="viewport" content="width=device-width, initial-scale=1.0">
  6 |   <title>Mikus</title>
  7 |   <link rel="stylesheet" href="styles.css">
  8 |   <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  9 | </head>
 10 | <body>
 11 |   <div class="sidebar">
 12 |     <h2>Mikus</h2>
 13 |     <ul>
 14 |       <li onclick="loadPost('about')">About Me</li>
 15 |       <li onclick="loadPost('posts/post1.md')">Transformer TTS</li>
 16 |       <li onclick="loadPost('posts/post2.md')">Post 2</li>
 17 |       <li onclick="loadPost('posts/post3.md')">Post 3</li>
 18 |     </ul>
 19 |   </div>
 20 | 
 21 |   <div class="content">
 22 |     <div id="post-content">
 23 |     </div>
 24 |   </div>
 25 | 
 26 |   <script src="script.js"></script>
 27 | </body>
 28 | </html>

-------------------------
